#!/bin/bash
# Mux-OS 超頻模式 (Overclock Mode)

# 安全檢測
if [ -z "$MUX_ROOT" ] || [ ! -f "$MUX_ROOT/.mux_state" ]; then
    echo -e "\033[1;35m[SO-xuM: FATAL] Core environment missing. Execution aborted.\033[0m"
    return 1 2>/dev/null || exit 1 
fi

if [ -z "$MUX_ROOT" ]; then export MUX_ROOT="$HOME/mux-os"; fi
export XUM_DB="$MUX_ROOT/xum.csv"

# 超頻讀取器 (Chamber Reader)
function _xum_neural_read() {
    unset _XUM_SLOT _XUM_PKG _XUM_TARGET _XUM_IHEAD _XUM_IBODY \
          _XUM_URI _XUM_MIME _XUM_CATE1 _XUM_CATE2 _XUM_CATE3 \
          _XUM_EX1 _XUM_TRA1 _XUM_BOO1 _XUM_EX2 _XUM_TRA2 _XUM_BOO2 \
          _XUM_EX3 _XUM_TRA3 _XUM_BOO3 _XUM_EX4 _XUM_TRA4 _XUM_BOO4 \
          _XUM_EX5 _XUM_TRA5 _XUM_BOO5 _XUM_FLAG _XUM_USER _XUM_RDY

    local target_slot="$1"
    local target_file="${2:-$XUM_DB}"

    if [ ! -f "$target_file" ]; then 
        echo -e "\033[1;31m :: ERROR: Chamber database not found.\033[0m" >&2
        return 1
    fi

    local raw_data=$(awk -v FPAT='([^,]*)|("[^"]+")' -v slot="$target_slot" '
        NR > 1 { 
            row_slot = $1; gsub(/^"|"$/, "", row_slot); gsub(/^[ \t]+|[ \t]+$/, "", row_slot)
            if (row_slot == slot) {
                print $0
                exit
            }
        }
    ' "$target_file")

    if [ -z "$raw_data" ]; then return 1; fi

    eval $(echo "$raw_data" | awk -v FPAT='([^,]*)|("[^"]+")' '{
        fields[1]="_XUM_SLOT"; fields[2]="_XUM_RDY"; fields[3]="_XUM_USER"
        fields[4]="_XUM_PKG"; fields[5]="_XUM_TARGET"; fields[6]="_XUM_IHEAD"
        fields[7]="_XUM_IBODY"; fields[8]="_XUM_URI"; fields[9]="_XUM_MIME"
        fields[10]="_XUM_CATE1"; fields[11]="_XUM_CATE2"; fields[12]="_XUM_CATE3"
        fields[13]="_XUM_EX1"; fields[14]="_XUM_TRA1"; fields[15]="_XUM_BOO1"
        fields[16]="_XUM_EX2"; fields[17]="_XUM_TRA2"; fields[18]="_XUM_BOO2"
        fields[19]="_XUM_EX3"; fields[20]="_XUM_TRA3"; fields[21]="_XUM_BOO3"
        fields[22]="_XUM_EX4"; fields[23]="_XUM_TRA4"; fields[24]="_XUM_BOO4"
        fields[25]="_XUM_EX5"; fields[26]="_XUM_TRA5"; fields[27]="_XUM_BOO5"
        fields[28]="_XUM_FLAG"

        for (i=1; i<=28; i++) {
            val = $i
            if (val ~ /^".*"$/) { val = substr(val, 2, length(val)-2) }
            gsub(/""/, "\"", val); gsub(/'\''/, "'\''\\'\'''\''", val)
            printf "%s='\''%s'\''; ", fields[i], val
        }
    }')
    
    return 0
}

# 火藥注入器 (Chamber Writer)
function _xum_neural_write() {
    local target_slot="$1"
    local col_idx="$2"
    local new_val="$3"
    local target_file="${4:-$XUM_DB}"

    if [ ! -f "$target_file" ]; then 
        echo -e "\033[1;31m :: ERROR: Chamber database not found.\033[0m" >&2
        return 1
    fi

    # 封裝引號與逃脫字元 (繼承兵工廠安全級別)
    local safe_val="${new_val//\\/\\\\}"
    safe_val="${safe_val//\"/\"\"}"

    # 第 1 欄 (SLOT) 保持純數字，其餘欄位包裹雙引號
    if [[ "$col_idx" == "1" ]]; then
        : 
    else
        if [ -n "$safe_val" ]; then
            safe_val="\"$safe_val\""
        fi
    fi

    # 原子寫入
    awk -v FPAT='([^,]*)|("[^"]+")' -v OFS="," \
        -v tslot="$target_slot" \
        -v col="$col_idx" \
        -v val="$safe_val" '
    {
        if (NR == 1) { print $0; next } # 標題行直接放行

        c = $1; gsub(/^"|"$/, "", c); gsub(/^[ \t]+|[ \t]+$/, "", c)

        if (c == tslot) {
            $col = val
        }
        print $0
    }' "$target_file" > "${target_file}.tmp" && mv "${target_file}.tmp" "$target_file"
}

# 超頻系統啟動器 (Overclock System Bootloader)
function _xum_system_boot() {
    _system_lock
    _safe_ui_calc
    
    # 自動生成基礎
    if [ ! -f "$XUM_DB" ]; then
        echo '"SLOT","RDY","USER","PKG","TARGET","IHEAD","IBODY","URI","MIME","CATE1","CATE2","CATE3","EX1","TRA1","BOO1","EX2","TRA2","BOO2","EX3","TRA3","BOO3","EX4","TRA4","BOO4","EX5","TRA5","BOO5","FLAG"' > "$XUM_DB"
        for i in {1..8}; do
            echo "$i,\"N\",,,,,,,,,,,,,,,,,,,,,,,,,," >> "$XUM_DB"
        done
    fi

    clear
    _draw_logo "xum"
    _system_check "xum"
    _show_hud "xum"
    _system_unlock
    _bot_say "hello"
}

# 保險裝置 (Ready to Chcek)
function _xum_update_rdy() {
    local slot="$1"
    local new_rdy="$2"
    local tmp_file=$(mktemp)
    
    awk -v FPAT='([^,]*)|("[^"]+")' -v s="$slot" -v r="$new_rdy" '
        BEGIN { OFS="," }
        NR == 1 { print $0; next }
        {
            row_slot = $1
            gsub(/^"|"$/, "", row_slot)
            if (row_slot == s) {
                $2 = "\"" r "\""
            }
            print $0
        }
    ' "$XUM_DB" > "$tmp_file" && mv "$tmp_file" "$XUM_DB"
}

# 選擇並檢驗彈巢 (Slot & Validate)
function _xum_cmd_slot() {
    local slot="$1"
    if [[ ! "$slot" =~ ^[1-8]$ ]]; then
        _bot_say "error" "INVALID CHAMBER: $slot. Provide 1-8."
        return 1
    fi

    # 1. 讀取記憶體
    _xum_neural_read "$slot"

    echo -e "${C_TAVIOLET} :: CHAMBER [$slot] PAYLOAD SCAN ::${C_RESET}"
    echo -e "${C_BLACK} -------------------------------------------${C_RESET}"

    # 2. 印出有值的參數 (過濾空值)
    local fields=("PKG" "TARGET" "IHEAD" "IBODY" "URI" "MIME" "FLAG" "USER")
    for f in "${fields[@]}"; do
        local val_var="_XUM_$f"
        [ -n "${!val_var}" ] && echo -e "  $f : \033[1;36m${!val_var}\033[0m"
    done
    
    # 印出 Extras
    for i in {1..5}; do
        local ex="_XUM_EX${i}"; local tra="_XUM_TRA${i}"; local boo="_XUM_BOO${i}"
        if [ -n "${!ex}" ]; then
            echo -e "  EX$i : \033[1;36m${!ex} \"${!tra}\" \"${!boo}\"\033[0m"
        fi
    done
    echo -e "${C_BLACK} -------------------------------------------${C_RESET}"

    # 3. 模擬組裝 am 指令 (檢驗)
    local cmd="am start"
    [ -n "$_XUM_USER" ] && cmd="$cmd --user $_XUM_USER"
    local action="${_XUM_IHEAD}${_XUM_IBODY}"
    [ -n "$action" ] && cmd="$cmd -a \"$action\""
    [ -n "$_XUM_URI" ] && cmd="$cmd -d \"$_XUM_URI\""
    [ -n "$_XUM_MIME" ] && cmd="$cmd -t \"$_XUM_MIME\""
    [ -n "$_XUM_PKG" ] && cmd="$cmd -p \"$_XUM_PKG\""
    # (此處為初步檢驗，省略完整 CATE/EX 組裝以保持快速)

    # 4. 判定是否為可執行狀態 (至少要有 Action, URI, 或 PKG)
    local is_valid=false
    if [ -n "$action" ] || [ -n "$_XUM_URI" ] || [ -n "$_XUM_PKG" ]; then
        is_valid=true
    fi

    # 5. 狀態機轉換 (N -> R)
    if [ "$is_valid" == true ]; then
        echo -e "${C_BLACK}  ›› [TEST_PAYLOAD]: $cmd${C_RESET}"
        if [ "$_XUM_RDY" == "N" ]; then
            _xum_update_rdy "$slot" "R"
            _XUM_RDY="R"
            echo -e "  \033[1;32m›› Parameter validation passed. Status: (N -> R)\033[0m"
        fi
    else
        echo -e "  \033[1;30m›› Chamber empty or incomplete. Status remains (N).\033[0m"
    fi

    # 6. 鎖定 Slot 焦點
    export XUM_CURRENT_SLOT="$slot"
    echo ""
    echo -e " ${C_TAVIOLET} ›› slot \"$slot\" locked.${C_RESET}"
}

# 解除保險 (R -> L)
function _xum_cmd_set() {
    local slot="$XUM_CURRENT_SLOT"
    if [ -z "$slot" ]; then
        _bot_say "error" "NO SLOT FOCUSED. Execute 'xum slot <n>' first."
        return 1
    fi
    
    _xum_neural_read "$slot"
    
    if [ "$_XUM_RDY" == "N" ]; then
        _bot_say "error" "CHAMBER [$slot] IS INCOMPLETE. CANNOT BE ARMED."
        return 1
    fi

    _xum_update_rdy "$slot" "L"
    _bot_say "success" "PAYLOAD [$slot] ARMED (L). READY TO FIRE."
}

# 關閉保險 (L -> R)
function _xum_cmd_unset() {
    local slot="$XUM_CURRENT_SLOT"
    if [ -z "$slot" ]; then
        _bot_say "error" "NO SLOT FOCUSED."
        return 1
    fi
    
    _xum_update_rdy "$slot" "R"
    _bot_say "warn" "PAYLOAD [$slot] DISARMED (R)."
}

# 槍管擊發、戰鬥報告與退殼機制 (Fire, Report & Eject)
function _xum_cmd_fire() {
    local slot="$XUM_CURRENT_SLOT"
    if [ -z "$slot" ]; then
        _bot_say "error" "NO SLOT FOCUSED. Execute 'xum slot <n>' first."
        return 1
    fi

    # 1. 讀取記憶體
    _xum_neural_read "$slot"
    
    if [ $? -ne 0 ]; then
        _bot_say "error" "MISFIRE: Chamber mechanism jammed."
        return 1
    fi

    # 2. 絕對保險檢查 (必須是 L)
    if [ "$_XUM_RDY" != "L" ]; then
        _bot_say "error" "CLICK! Chamber [$slot] is not armed. Status is [$_XUM_RDY], requires [L]."
        return 1
    fi

    _bot_say "system" "IGNITION SEQUENCE START. DISCHARGING PAYLOAD..."

    # 3. 動態組裝 am start 指令
    local cmd="am start"
    [ -n "$_XUM_USER" ] && cmd="$cmd --user $_XUM_USER"
    local action="${_XUM_IHEAD}${_XUM_IBODY}"
    [ -n "$action" ] && cmd="$cmd -a \"$action\""
    [ -n "$_XUM_URI" ] && cmd="$cmd -d \"$_XUM_URI\""
    [ -n "$_XUM_MIME" ] && cmd="$cmd -t \"$_XUM_MIME\""
    
    for cate in "$_XUM_CATE1" "$_XUM_CATE2" "$_XUM_CATE3"; do
        [ -n "$cate" ] && cmd="$cmd -c \"android.intent.category.$cate\""
    done
    
    [ -n "$_XUM_FLAG" ] && cmd="$cmd -f $_XUM_FLAG"

    for i in {1..5}; do
        local ex_var="_XUM_EX${i}"; local tra_var="_XUM_TRA${i}"; local boo_var="_XUM_BOO${i}"
        local ex_val="${!ex_var}"; local tra_val="${!tra_var}"; local boo_val="${!boo_var}"
        if [ -n "$ex_val" ]; then
            cmd="$cmd $ex_val"
            [ -n "$tra_val" ] && cmd="$cmd \"$tra_val\""
            [ -n "$boo_val" ] && cmd="$cmd \"$boo_val\""
        fi
    done

    if [ -n "$_XUM_PKG" ] && [ -n "$_XUM_TARGET" ]; then
        cmd="$cmd -n \"$_XUM_PKG/$_XUM_TARGET\""
    elif [ -n "$_XUM_PKG" ]; then
        cmd="$cmd -p \"$_XUM_PKG\""
    fi

    # 4. 擊發並捕捉結果
    local output
    output=$(eval "$cmd" 2>&1)

    # 5. 判定結果狀態
    local fire_status="Success"
    if [[ "$output" == *"Error"* ]] || [[ "$output" == *"does not exist"* ]] || [[ "$output" == *"unable to resolve"* ]]; then
        fire_status="Failure"
        _bot_say "error" "MISFIRE DETECTED."
    else
        _bot_say "success" "TARGET HIT."
    fi

    # 6. 產出戰鬥報告 (AAR)
    local report_time=$(date +"%Y.%m.%d.%H:%M:%S")
    local report_file="$MUX_ROOT/report.txt"
    
    # 建立多行報告字串
    local report_content="-----
Time: $report_time
Playload: $cmd
Status: $fire_status
Output: $output"

    # 寫入實體檔案 (附加模式)
    echo "$report_content" >> "$report_file"

    # 7. 印出報告給使用者
    echo -e "${C_TAVIOLET} :: AFTER ACTION REPORT ::${C_RESET}"
    echo "$report_content" | while read -r line; do
        if [[ "$line" == "Status: Success" ]]; then
            echo -e "  \033[1;32m$line\033[0m"
        elif [[ "$line" == "Status: Failure" ]]; then
            echo -e "  \033[1;31m$line\033[0m"
        elif [[ "$line" == "-----" ]]; then
            echo -e "${C_BLACK}  $line${C_RESET}"
        else
            echo -e "  $line"
        fi
    done
    echo ""

    # 8. 物理退殼 (清空 CSV 該 Slot 內的所有資料，並重置為 N)
    local tmp_file=$(mktemp)
    awk -v FPAT='([^,]*)|("[^"]+")' -v s="$slot" '
        BEGIN { OFS="," }
        NR == 1 { print $0; next }
        {
            row_slot = $1
            gsub(/^"|"$/, "", row_slot)
            if (row_slot == s) {
                $2 = "\"N\""
                for(i=3; i<=28; i++) {
                    $i = ""
                }
            }
            print $0
        }
    ' "$XUM_DB" > "$tmp_file" && mv "$tmp_file" "$XUM_DB"
    
    # 解除焦點鎖定並宣告退殼
    export XUM_CURRENT_SLOT=""
    _bot_say "system" "CHAMBER [$slot] EJECTED. SLOT RESET TO (N)."
}

# 槍管退膛與系統降壓 (Chamber Eject & System Cooldown)
function _xum_cmd_reset() {
    _bot_say "warn" "INITIATING CORE COOLDOWN SEQUENCE..."
    
    # --------------------------------------------------
    # [預留位置]：未來將在此處寫入 Unix 時間戳記 (2小時物理鎖)
    # --------------------------------------------------

    if [ -f "$XUM_DB" ]; then
        rm -f "$XUM_DB"
        echo -e "${C_BLACK}  ›› [SECURE WIPE]: Chamber database permanently destroyed.${C_RESET}"
    fi
    _bot_say "success" "TERMINATING OVERCLOCK PROTOCOL. REVERTING TO KERNEL STANDARDS."
    
    _update_mux_state "MUX" "LOGIN" "COCKPIT"
    _mux_reload_kernel
}

function xum() {
    local cmd="$1"
    local arg="$2"

    # 若無指令，預設的視覺回饋或亂碼擋板
    if [ -z "$cmd" ]; then
        return 0
    fi

    # XUM 指令分流閘 (Command Switch)
    case "$cmd" in
        # : Select Ammo Chamber
        "slot")
            _xum_cmd_slot "$arg"
            ;;
            
        # : Open Tactical Status Panel
        "status"|"sts")
            _xum_ui_status_panel
            ;;
            
        # : Inject Payload parameters
        "set")
            _xum_cmd_set
            ;;
        
        # : Disarm the loaded Payload
        "unset")
            _xum_cmd_unset
            ;;
            
        # : Discharge the loaded Payload
        "fire")
            _xum_cmd_fire
            ;;
            
        # : Terminate Overclock & return to Core
        "reset")
            _xum_cmd_reset
            ;;

        "help")
            _xum_dynamic_help
            return 0
            ;;
            
        *)
            _bot_say "error" "UNKNOWN XUM DIRECTIVE: $cmd"
            return 1
            ;;
    esac
}

# 測試函式：驗證讀寫功能
# 僅在直接執行此腳本時運行，如果被 source 則忽略
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo ":: [PROJECT XUM] I/O Test Sequence Initiated ::"
    
    # 測試寫入：將 Slot 1 的 PKG (第 2 欄) 寫入 "com.test.xum"
    echo "› Writing to Slot 1 (Column 2)..."
    _xum_neural_write "1" 2 "com.test.xum"
    
    # 測試寫入：將 Slot 1 的 EX1 (第 11 欄) 寫入 "--es"
    echo "› Writing to Slot 1 (Column 11)..."
    _xum_neural_write "1" 11 "--es"
    
    # 測試讀取：讀出 Slot 1 驗證
    echo "› Reading from Slot 1..."
    _xum_neural_read "1"
    
    echo "---------------------------"
    echo "SLOT : $_XUM_SLOT"
    echo "PKG  : $_XUM_PKG"
    echo "EX1  : $_XUM_EX1"
    echo "RDY  : $_XUM_RDY"
    echo "---------------------------"
    echo ":: Test Complete ::"
fi

